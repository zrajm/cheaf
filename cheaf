#!/usr/bin/python3
"""Usage: cheaf [options] <command> [<args>...]

Cheaf (the .eaf chef) is a tool for processing ELAN files.

Options:
  -h,--help           show help information about cheaf (same as 'help')
  -V,--version        show version information
  -C,--color=WHEN     colorize the output; WHEN can be 'always', 'auto', or
                      'never'; more info below [default: auto]
  -H,--with-filename  show filename for each
              Print the file name for each match.  This is  the  default  when
              there is more than one file to search.
  -h,--no-filename    suppress filename for each match
              Suppress  the  prefixing  of  file names on output.  This is the
              default when there is only one file (or only standard input)  to
              search.

Commands:
  annot <tier> <file>...   show annotations in
  extract-video <file>...  *NYI
  help [<command>]         show help information about cheaf (or cheaf command)
  tiers <file>...          list tier names

NOTE: The option '-h' is interpreted as '--no-filename' only if it comes before
a <command>, otherwise it is interpreted as '--help' (allowing you to quickly
add a '-h' at the end of a previously failed command in order to read up on
it).

FIXME:
  * add command for replacing media in .eaf file
  * add command for dumping .eaf as JSON
"""
__version__ = "0.0.10"
__copyright__ = "Copyright (C) 2019-2022 zrajm <zrajm@klingonska.org>"
__license__ = """GPLv2: GNU General Public License, version 2,
  <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>"""

import os
import string
import errno
import re
import sys

_exe = os.path.basename(__file__)
_info = """%s %s
%s
License %s.
This is free software: you are free to change and redistribute it.""" % (
    _exe,
    __version__,
    __copyright__,
    __license__,
)

# Import non-standard modules
try:
    from pympi import Elan
except ImportError:
    sys.exit("""%s: Missing module 'pympi'\n
    Install with: 'pip3 install pympi-ling'\n""" % _exe)
try:
    from docopt import docopt, DocoptExit
except ImportError:
    sys.exit("""%s: Missing module 'docopt'\n
    Install with: 'pip3 install docopt'\n""" % _exe)

################################################################################
##                                                                            ##
##  Helper Functions                                                          ##
##                                                                            ##
################################################################################

# Open eaf file or die.
def open_eaf(filename):
    try:
        # Temporarily swap STDOUT <=> STDERR because pympi Elan module have a
        # nasty habit of outputting error messages on STDOUT. :(
        sys.stdout, sys.stderr = sys.stderr, sys.stdout
        eaf = Elan.Eaf(filename)
        sys.stdout, sys.stderr = sys.stderr, sys.stdout
        return eaf
    except OSError as e:
        print(
            "Cannot open ELAN file '%s': %s" % (e.filename, e.args[1]),
            file=sys.stderr
        )
        return None

################################################################################
##                                                                            ##
##  Sub-Command Functions                                                     ##
##                                                                            ##
################################################################################

def cmd_help(args):
    """Usage: cheaf help [<command>]

Show help information about the given cheaf <command> (or general information
about cheaf, if no command was specified).

Options --help or -h also invoke this command. Though, if the short form (-h)
is used before <command> then it acts as the --no-filename option. The long
form (--help) may appear anywhere on the command line. (If a command fail on
you, you may always re-execute the command with an added -h at the end to check
the help info for the cheaf command you ran. -- When a help option is used, all
other options, except for the first given <command> are intentionally
ignored.)"""
    cmd = args["<command>"]
    if cmd:
        func = get_command_func(cmd)
        if func == None:
            error("'%s' is not an cheaf command" % cmd)
        doc = func.__doc__
    else:
        doc = __doc__
    import inspect
    print(inspect.cleandoc(doc))

# WORKING?
def cmd_annot(args):
    """Usage: cheaf annot [options] [--] <file>...

Options:
  -t,--tier=REGEX   only output annotations in tiers with matching name

Output matching annotations in <file>s. Output values are tab separated, and
each line include start time, end time, tier name and the annotation value.
(Time is output in 'h:mm:ss.ddd' format.)

Global option --with-filename will prepend each line with filename (also tab
separated), and if --color is in use then matching strings will be highlighted
in the output.

No distinction is made between the EAF format's <ALIGNABLE_ANNOTATION> and
<REF_ANNOTATION> â€“ They are both included in the output, formatted in the same
way. (I have yet to find a situation where distinguishing the two is relevant.)

TODO: <tier> should support regex pattern."""
    filenames = args["<file>"]
    print_tty("%s\t%s\t%s" % ("BEGIN", "END", "VALUE"))
    for filename in filenames:
        eaf = open_eaf(filename)
        tiers = eaf.tiers

        regex = None
        if args["--tier"] != None:
            regex = re.compile('(%s)' % args["--tier"])
            tiers = filter(regex.match, eaf.tiers)

        for tiername in tiers:
            tiername_out = tiername
            if args["color"] and regex != None:
                tiername_out = regex.sub('\x1B[7m\\1\x1B[m', tiername)

            for annot in eaf.get_annotation_data_for_tier(tiername):
                try:                            # <ALIGNABLE_ANNOTATION>
                    begin_ms, end_ms, value           = annot
                except ValueError as e:         # <REF_ANNOTATION>
                    begin_ms, end_ms, value, referent = annot

                begin_ms = stringify_ms(begin_ms)
                end_ms   = stringify_ms(end_ms)
                if args["show_filenames"]:
                    print("%s\t%s\t%s\t%s\t%s" % (filename, begin_ms, end_ms, tiername_out, value))
                else:
                    print("%s\t%s\t%s\t%s"     % (          begin_ms, end_ms, tiername_out, value))

# WORKING?
def cmd_extract_video(args):
    """Usage: cheaf extract-video <tier> <file>... <outdir>
       cheaf extract-video --help

TODO: NOT YET IMPLEMENTED

Extract video snippets corresponding to each of the annotations in the given
<tier> in each of the <file>s. Output is written to <outdir> (which is created
if it does not already exist).

Options:
  -?,--help  display this help and exit"""

    filenames, tiername = args["FILE"], args["TIER"]
    for filename in filenames:
        eaf = Elan.Eaf(filename)
        tiers = eaf.tiers
        media = eaf.get_linked_files()
        print("MEDIA")
        print(media)
        print(media[0]['MEDIA_URL'])
        count = {}
        if tiername not in tiers:
            warn("Tier '%s' not found" % tiername)
        else:
            for anno in eaf.get_annotation_data_for_tier(tiername):
                (beg, end, gloss) = anno
                count[gloss] = 1 if gloss not in count else count[gloss] + 1
                outfile = "%s-%05d.mp4" % (gloss.lower(), count[gloss])
                duration = end-beg
                print("""----------------
GLOSS: %s
OUTNAME: %s
FILE: %s
TIER: %s
BEG: %ss\t%sms
DUR: %ss\t%sms
ffmpeg -ss %.10g -i %s -c copy -t %.10g %s""" % (
    gloss,
    outfile,
    filename,
    tiername,
    beg/1000, beg,
    duration/1000, duration,
    beg/1000, filename, duration/1000, outfile
    # The timestamps need to be in HH:MM:SS.xxx format or in seconds (s.msec)
    #ffmpeg -ss <start> -i <file> -c copy -t <duration> output.wmv
))

# WORKS
def cmd_tiers(args):
    """Usage: cheaf tiers [--] <file>...

List names of all tiers in specified <file>s."""
    for filename in args["<file>"]:
        eaf = open_eaf(filename)
        tiers = eaf.tiers
        for tiername in tiers.keys():
            if args["show_filenames"]:
                print("%s: %s" % (filename, tiername))
            else:
                print("%s" % tiername)

################################################################################

def print_tty(args):
    if sys.stdout.isatty():
        print(args)

def warn(msg, *args):
    binname = os.path.basename(__file__)
    print("%s: %s" % (binname, msg), *args, file=sys.stderr)

def read_elan_file(filename):
    eaf = Elan.Eaf(filename)

def get_command_func(command):
    try:
        return globals()["cmd_" + re.sub("-", "_", command)]
    except:
        return None

# Split argv into global option + subcommand and subcommand + command options.
def split_args(args):
    i = 0
    for arg in args:
        if arg[:1] != '-': break
        i += 1
    return args[:i+1], args[i:]

def die(msg, subcmd = ''):
    sys.exit(("%s: %s. See 'cheaf %s --help'." % (_exe, msg, subcmd))
             .replace('  ', ' '))

def error(msg):
    sys.exit("%s: %s" % (_exe, msg))

def stringify_ms(ms):
    """Convert EAF milliseconds to [h:]mm:ss.ddd[ddd] format. (Hours are left out
    if zero, same with any decimals except the first three.)

    Make sure there are exactly three decimals (if possible). Prettifies output
    by giving all timestamps the same length. This is done by grabbing leading
    non-zero decimals, then zero-padding to three places. Needed because EAF
    files only have millisecond precision (i.e. to three decimal places), but
    Python 'datetime' return either six or zero decimals. This only ever strip
    off trailing *zeroes*, so, if there are more than three non-zero decimals
    (or if the hour is non-zero) then returned values will have variable
    length.
    """
    import datetime
    timestr = str(datetime.timedelta(seconds = ms / 1000))
    timestr = re.sub(r'^0+:', '', timestr, 1)  # strip hours (if zero)
    return re.sub(                             # prefer 3 decimal places
        r'(?:([.][0-9]+?)0*)?$',
        lambda m: (m.group(1) if m.group(0) else '.').ljust(4, '0'),
        timestr,
        1,
    )

# Return name of the command for which help was requested, or None if no
# '--help', '-h' option or 'help' command was found. '-h' may only occur after
# a command (if it comes before it's an alias for the global option
# '--no-filename'). Command line scanning stops if '--' is encountered.

# 'help' (first command)
#   cheaf help       -> help (no cmd)
#   cheaf -h help    -> help (no cmd)
#   cheaf help annot -> help 'annot'
#   cheaf annot help -> no help (invokes 'annot' with arg 'help')
#
# '-h' (must come after command)
#   cheaf -h         -> help (no cmd)
#   cheaf help -h    -> help 'help'
#   cheaf annot -h   -> help 'annot'
#   cheaf -h annot   -> no help (invokes 'annot')
#
# '--help' (anywhere on command line)
#   cheaf --help        -> help (no cmd)
#   cheaf --help annot  -> help 'annot'
#   cheaf annot --help  -> help 'annot'
#
def get_help_option(argv):
    lopt  = False  # '--help' found
    shopt = False  # '-h' found (nulled if command is found)
    cmds = []      # commands found
    for arg in argv[1:]:
        if arg == '--': break
        elif arg[:1] != '-':
            cmds.append(arg)
            if lopt: return (True, cmds[0])
            shopt = False
        elif arg == '-h':
            if cmds: return (True, cmds[0])
            shopt = True
        elif arg == '--help':
            if cmds: return (True, cmds[0])
            lopt = True
    if shopt or lopt:         # '--help' or '-h'
        return (True, None)
    try:                      # 'help'
        if cmds[0] == 'help':
            try   : return (True, cmds[1])  # w/  arg
            except: return (True, None)     # w/o arg
    except: pass
    return (False, None)

################################################################################
##                                                                            ##
##  Main                                                                      ##
##                                                                            ##
################################################################################

def main():
    # Split into pre- and post-command arguments.
    global_argv, cmd_argv = split_args(sys.argv[1:])

    helpopt, helpcmd = get_help_option(sys.argv)
    if helpopt:                                  # help option/command used?
        args = { '<command>':  helpcmd }
        cmdfunc = get_command_func('help')
        cmdfunc(args)                            # call subcommand function
        sys.exit()

    # Parse global options.
    try:
        args = docopt(re.sub(r'.*--help .*\n', '', __doc__),
                      version=_info, argv=global_argv, help=False)
    except DocoptExit as e:
        if global_argv and global_argv[-1][0] == "-":
            die("Missing cheaf command")
        else:
            die("Unknown arguments")

    # Get subcommand function.
    del args["<args>"]                         # always empty
    cmd_name = args.pop("<command>")           # always the command name
    cmdfunc = get_command_func(cmd_name)
    if cmdfunc == None:
        die("'%s' is not a cheaf command" % cmd_name)

    # Parse subcommand options.
    try:
        subargs = docopt(cmdfunc.__doc__, argv=cmd_argv, help=False)
    except DocoptExit as e:
        die("Unknown arguments for cheaf command '%s'" % cmd_name, cmd_name)
    del subargs[cmd_name]                      # always the command name
    args.update(subargs)

    if "<file>" in args:
        args["show_filenames"] = True if len(args["<file>"]) > 1 else False
        if args["--no-filename"]: args["show_filenames"] = False
        if args["--with-filename"]: args["show_filenames"] = True
        del args["--no-filename"], args["--with-filename"]

    # set 'color' (from '--color' option or default value)
    if args["--color"] in ("always", "yes", "force"):
        args["color"] = True
    elif args["--color"] in ("never", "no", "none"):
        args["color"] = False
    elif args["--color"] in ("auto", "tty", "if-tty"):
        args["color"] = True if sys.stdout.isatty() else False;
    else:
        error((
            "Unknown argument '%s' for '--color'\n" +
            "Available arguments are:\n" +
            "  - 'always', 'yes', 'force'\n" +
            "  - 'never', 'no', 'none'\n" +
            "  - 'auto', 'tty', 'if-tty'") % args["--color"]
        )

    # Call subcommand function.
    cmdfunc(args)
    sys.exit()

if __name__ == '__main__':
    try: main()
    except ConnectionError:
        sys.exit()
    except KeyboardInterrupt:
        sys.exit('***BREAK keyboard interrupt')

#[eof]
